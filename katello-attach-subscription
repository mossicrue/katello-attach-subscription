#!/usr/bin/env ruby

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.

## MARK: Requirements & Bootstrap

# support for bundler, currently commented out
#require 'rubygems'
#require 'bundler/setup'
require 'optparse'
require 'yaml'
require 'apipie-bindings'
require 'rest-client'
require 'json'
require 'csv'
require 'thread'

require_relative 'lib/katello_attach_subscription'

# force the output to be sent to stdout in a sync way
$stdout.sync = true

@defaults = {
  :noop                   => false,
  :uri                    => 'https://localhost/',
  :timeout                => 300,
  :user                   => 'admin',
  :pass                   => 'changeme',
  :org                    => 1,
  :usecache               => false,
  :cachefile              => 'katello-attach-subscription.cache',
  :virtwho                => false,
  :virtwhocachefile       => 'virt-who.cache',
  :emptyhypervisor        => false,
  :debug                  => false,
  :verbose                => false,
  :search                 => nil,
  :density                => false,
  :densityfile            => 'cluster-state.csv',
  :guestreportfile        => 'guest-report.csv',
  :densityvalue           => 4,
  :elsdensityvalue        => 4,
  :elsosversion           => "<6",
  :subreport              => false,
  :subreportfile          => 'sub-report.csv',
  :detailedsubreportfile  => 'detailed-report.csv',
  :verify_ssl             => true,
  :repeatAPI              => false,
  :maxstep                => 1,
  :sleepAPI               => false,
  :sleepTime              => 0,
  :sleepMult              => 1,
  :multisearch            => false,
  :clean_sub              => false,
  :maxthread              => 2,
  :auto_heal              => "noop"
}

@options = {
  :yamlfile  => 'katello-attach-subscription.yaml',
}


## MARK: Options Parsing

# Parse the command line options
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{opts.program_name} [options]"
  opts.version = "0.1"

  opts.on("-U", "--uri=URI", "URI to the Satellite") do |u|
    @options[:uri] = u
  end
  opts.on("-t", "--timeout=TIMEOUT", OptionParser::DecimalInteger, "Timeout value in seconds for any API calls. -1 means never timeout") do |t|
    @options[:timeout] = t
  end
  opts.on("-u", "--user=USER", "User to log in to Satellite") do |u|
    @options[:user] = u
  end
  opts.on("-p", "--pass=PASS", "Password to log in to Satellite") do |p|
    @options[:pass] = p
  end
  opts.on("-o", "--organization-id=ID", "ID of the Organization") do |o|
    @options[:org] = o
  end
  opts.on("-c", "--config=FILE", "configuration in YAML format") do |c|
    @options[:yamlfile] = c
  end
  opts.on("-n", "--noop", "do not actually execute anything") do
    @options[:noop] = true
  end
  opts.on("-s", "--search=SEARCH", "search for machines matching this string only") do |s|
    @options[:search] = s
  end
  opts.on("--read-from-cache", "use, if possible, cache file") do
    @options[:usecache] = true
  end
  opts.on("--cache-file=FILE", "read or write to cache file, based on --read-from-cache value") do |cf|
    @options[:cachefile] = cf
  end
  opts.on("--virt-who", "use the command virt-who --print to retrieve the cpu.cpu_socket(s)'s data of the hypervisors.") do
    @options[:virtwho] = true
  end
  opts.on("--virt-who-file=FILE", "read or write to virt-who cache file, based on --read-from-cache value and --virt-who.") do |vwf|
    @options[:virtwhocachefile] = vwf
  end
  opts.on("--empty-hypervisor", "remove all the empty hypervisor from Satellite before apply the subscription process. Not compatible with --check-density option.") do
    @options[:emptyhypervisor] = true
  end

  opts.on("--check-density", "check if all hosts in a cluster has an average number of guests >= 5 for assigning VDC Subscription. Not compatible with --empty-hypervisor option.") do
    @options[:density] = true
  end
  opts.on("--check-density-value=VALUE", "check if all hosts in a cluster has an average number of guests >= VALUE for assigning VDC Subscription. Not compatible with --empty-hypervisor option.") do |val|
    @options[:densityvalue] = val
  end
  opts.on("--check-density-file=FILE", "Write report of cluster state to custom file. Not compatible with --empty-hypervisor option.") do |crf|
    @options[:densityfile] = crf
  end

  opts.on("--print-subscription-report", "Print a report for the subscription used by of all hosts") do
    @options[:subreport] = true
  end
  opts.on("--print-subscription-report-file=FILE", "Print a report for the subscription in a custom file used by of all hosts") do |srf|
    @options[:subreportfile] = srf
  end

  opts.on("--multiple-search", "Allow to search content-hosts with the order of query result in yaml configuration file") do
    @options[:multisearch] = true
  end

  opts.on("--clean-same-product", "Ensure that all the content hosts has 1 subscriptions for every product found from yaml configuration file") do
    @options[:clean_sub] = true
  end

  opts.on("--host-auto-heal=VALUE", "Disable or enable auto-attach process on Satellite content hosts (Accepted value: 'noop' 'Enable' or 'Disable')") do |setting|
    if setting.downcase == "enable" or setting.downcase == "disable"
      @options[:auto_heal] = setting.downcase
    else
      @options[:auto_heal] = "noop"
    end
  end

  opts.on("--repeat-API", "Allow to repeat API for a certain number before fail") do
    @options[:repeatAPI] = true
  end
  opts.on("--max-step=MAX_STEP", "Set the number of tentative which API try to repeat API Call in case of fails") do |step|
    @options[:maxstep] = step
  end
  opts.on("--repeat-API-sleep", "Allow to add an incremental waiting time configurable via configuration file") do
    @options[:sleepAPI] = true
  end

  opts.on("--concurrency-mode", "Allow to assign subscription to hosts in parallel, as setted in configuration file") do
    @options[:concurrency] = true
  end

  opts.on("-v", "--verbose", "verbose output for the script") do
    @options[:verbose] = true
  end
  opts.on("-d", "--debug", "debug output for the script") do
    @options[:verbose] = true
    @options[:debug] = true
  end
  opts.on("--no-verify-ssl", "don't verify SSL certs") do
    @options[:verify_ssl] = false
  end
end
optparse.parse!

# load the configuration files settings
@yaml = YAML.load_file(@options[:yamlfile])

@virtwho_location = ""

# override configuration files settings with command lines one
if @yaml.has_key?(:settings) and @yaml[:settings].is_a?(Hash)
  @yaml[:settings].each do |key,val|
    if not @options.has_key?(key)
      @options[key] = val
    end
  end
end

# check if incompatible options are present
if @options[:emptyhypervisor] and @options[:density]
  puts "FATAL ERROR: Script can't run with --empty-visor and --check-density options enabled. Choose only one."
  exit 5
end

# check if virt-who is intalled and obtain location
if @options[:virtwho]
  if @options[:verbose]
   puts "--virt-who options enabled. Check if virt-who is installed"
  end
  @virtwho_location = `which virt-who`
  if not $?.exited? or $?.exitstatus.to_i != 0
    puts "FATAL ERROR: --virt-who option requested, but virt-who is not installed. re run without --virt-who or install it."
    exit 5
  end
  @virtwho_location = @virtwho_location.chop!
  if @options[:debug]
    puts " DEBUG: virt-who is installed in #{@virtwho_location}"
  end
end

# if options sleepAPI get the value of :base and :multiplier from the configuration yaml file
if @options[:sleepAPI]
  if @yaml.has_key?(:sleep)
    # if the :base value isn't present there will used the default one specified at the start of the code
    if @yaml[:sleep].has_key?(:base)
      @options[:sleepTime] = @yaml[:sleep][:base]
    else
      if @options[:debug]
        puts " DEBUG: --sleep-API option requested, but :base value not configured in YAML file, using default value"
      end
    end
    # if the :base value isn't present there will used the default one specified at the start of the code
    if @yaml[:sleep].has_key?(:multiplier)
      @options[:sleepMult] = @yaml[:sleep][:multiplier]
    else
      if @options[:debug]
        puts " DEBUG: --sleep-API options requested but :multiplier value not configured in YAML file, using default value"
      end
    end
  end
end

# satellite url has to start with https or PUT will fail with http error
unless @options[:uri].start_with?('https://')
  abort "FATAL ERROR: the uri must start with https://"
end

# missing configuration parameters from file or command line are taken from the default one
@defaults.each do |key,val|
  if not @options.has_key?(key)
    @options[key] = val
  end
end


## MARK: Global Variables

# binding api
@api = ApipieBindings::API.new({:uri => @options[:uri], :username => @options[:user], :password => @options[:pass], :api_version => '2', :timeout => @options[:timeout]}, {:verify_ssl => @options[:verify_ssl]})

# availability of virt-who data after cache parsing or virt-who --print running
@virtwho_data = false

# parsed hypervisors from virt-who cache or virt-who --print retrieved data
@parsed_hypervisors_hash = {}

# list of cluster that has density >= @options[:densityvalue]
@full_cluster  = []

# list of cluster that has density < @options[:densityvalue]
@empty_cluster = []

# list of cluster data calculated for --check-density options
@cluster_data = []

# lsit of hypervisor with cluster data attached on every hypervisor entry, used for checking density of the cluster
@clustered_hypervisor_list = []

# hash of the subscription that we need to attach to all host for getting every host fully entitled
@subs_count = {}

# array with all the guest detail for the guest/host/cluster report
@guest_list = []

# array with all the subs consumed by all the hosts
@detailed_report = []

# list of hosts id that are already passed in katello-attach-subscription
@checked_hosts = []

# hash of hypervisor with their parsed desired sub
@desired_product = {}

# number of current spawned thread
@current_thread = 0

## MARK: Main Functions

# functions that check subscriptions and prerequisites data
def checksubs()
  # initialize variables
  # by default any kind of subscription is fine
  subfiltertype = nil
  cachepresent = false
  if @options[:usecache]
    # read cached sub from cache file searching 'subs'
    puts_standard "Reading subscription from cache."
    cachefile = "#{@options[:cachefile]}_org#{@options[:org]}"
    @yaml[:subs] = readfromcache(cachefile, 'subs')
    # if readed subs are present set cachepresent as true
    if @yaml[:subs].count > 0
      cachepresent = true
    end
  end

  # sanity check and fix of yaml file for subscription
  # going to check if any id in the yaml do not exists, and expand the search keys
  # sub will keep the originally requested subscriptions, sub_parsed the found one
  if not cachepresent
    puts_standard "  Subscription parsing started. Please be patient."
    subsyamltotalentry = @yaml[:subs].count
    @yaml[:subs].each_with_index do |sub, subcurrentcount|
      # search always for NORMAL sub as they could be attached booth hypervisor, physical and guest host
      subfiltertype = "NORMAL"
      puts_standard "    Started parsing entry #{subcurrentcount+1}/#{subsyamltotalentry}"
      # check if the hash contains data. If not, skip it.
      if not sub.is_a?(Hash)
        puts_standard "    YAML entry without valid data, like empty entry. No further actions on this entry."
        next
      end
      # starting the process
      puts_verbose "    started parsing for entry '#{sub["hostname"]}'"
      puts_verbose "    subs look for host type '#{sub["type"]}', looking for '#{subfiltertype}' subscriptions"
      # check only the sub section
      # if sub is empty, auto-attach
      if sub.has_key?('sub')
        # initialize variables
        sub_parsed = {}
        desired_sub_hash = sub['sub']
        if not desired_sub_hash.is_a?(Hash)
          puts_standard "    YAML entry without valid data, like empty subscription. As no valid subscriptions are listed, that will be deleted on the given hosts."
          next
        end
        # for every product (hash key in yaml) check the desired subs
        desired_sub_hash.each do |product, desidered_product_sub_array|
          parsed_product_sub_array = []
          puts_standard "    Started parsing for product '#{product}'"
          puts_debug "    in the desired_sub_hash, desidered_product_sub_array: #{desidered_product_sub_array}"
          desidered_product_sub_array.each do |subscription_item|
            parsed_subscription = []
            puts_verbose "      parsing subscription '#{subscription_item}'"
            # fetch all the result searching subscription by their name, stored in subscription_item
            search_options = KatelloAttachSubscription::Utils.search_args(subscription_item)
            parsed_subscription = fetch_all_results(:subscriptions, :index, {:search => search_options, :available_for => "host"})
            # if the lookup has given no results at all, no subscriptions has to be added
            if parsed_subscription.empty?
              puts_standard "      Subscription parsing results of search string '#{subscription_item}' is empty, not adding any subscription"
              next
            end
            puts_debug "    retrieved subscription", parsed_subscription
            # if empty, so zero results, this will be simply skipped
            parsed_subscription.each do |subscription|
              puts_debug "      subscription detail for subscription #{subscription['cp_id']}:", subscription
              # The type is defined in yaml. Currently handling only the Hypervisor subs, derivated one should be not considered for hypervisors.
              if subfiltertype and subscription.has_key?('type') and subscription['type'] != subfiltertype
                puts_verbose "      Skipping '#{subscription['cp_id']}' as system type '#{subscription['type']}' is different from desired '#{subfiltertype}'"
                # if the filter do not match, skip to next subscription
                next
              end
              parsed_product_sub_array.push(subscription['cp_id'])
            end
            puts_standard "    Subscription parsing results of search string '#{subscription_item}' is #{parsed_product_sub_array}"
            # push new subs to array with new key for this product
            sub_parsed[product] = parsed_product_sub_array
            # and copy to the pointer for this product
            # sub['sub'] are the requested subs
            # sub['sub_parsed'] are the subs found that has to be associated
            sub['sub_parsed']=sub_parsed
          end
        end
      end
    end
    puts_debug "  the full yaml subs output after modification", @yaml[:subs]
  end

  # if virt-who option is enabled we are going to execute the command virt-who --print to retrieve
  # hypervisors data and so their number of socket
  json_hash = {}
  run_virtwho_print = false

  puts_debug "virt-who enabled: #{@options[:virtwho]}"

  if @options[:virtwho]
    # virt-who cachefile contain the cached data of the json with the hypervisor data
    # the desired pattern for the name of this cache file is virt-who-{ date in yyyymm }.cache_org{ organization id }
    virtwho_cachefile = @options[:virtwhocachefile].to_s + "_org" + @options[:org].to_s
    # assuming that no cache is present
    run_virtwho_print = true
    # :usecache options is enabled, before launch virt-who --print, try to read the cache file
    if @options[:usecache]
      run_virtwho_print = false
      # read virt-who cache calling readfromcache function
      cachefile = "#{@options[:virtwhocachefile]}_org#{@options[:org]}"
      json_hash = readfromcache(cachefile, '')
      puts_debug "raw virt-who.cache parsed data", json_hash
      # check if the json_hash contains valid data by calling validhypervisordata functions
      if KatelloAttachSubscription::VirtWhoHelper.validhypervisordata(json_hash)
        # check the sanity of every hypervisor, searching if the data we need are present
        puts_standard "Starting virt-who cache file parsing. Please be patient."
        @parsed_hypervisors_hash = KatelloAttachSubscription::VirtWhoHelper.cleanhypervisorfromrawvirtwho(json_hash)
        # if parsed_hypervisors_hash isn't empty then virt-who --print should not run
        if not @parsed_hypervisors_hash.empty?
          run_virtwho_print = false
          @virtwho_data = true
        else
          # if parsed_hypervisors_hash is empty then try to run virt-who --print to retrieve data
          puts_standard " Hypervisor parsing results from cache is empty, 'virt-who --print' will run to retrieve data"
          run_virtwho_print = true
        end
      else
        # if returned value is false then run virt-who --print to retrieve data
        puts_standard "Invalid or empty JSON of virt-who cache file, 'virt-who --print' will run to retrieve data"
        run_virtwho_print = true
      end
    end
    # if run_virtwho_print is true then run virt-who --print
    if run_virtwho_print
      puts_standard "Running the command '#{@virtwho_location} --print' to retrieve Hypervisors data. Please be patient."

      # decomment if virt-who run as a service to stop it and avoid error from virt-who print
      # RHEL 7
      # `systemctl stop virt-who`
      # RHEL 5, 6
      # service virt-who stop
      # run virt-who --print and send debug output to /dev/null as it's not useful for the script

      virtwho_print_output = `#{@virtwho_location} --print 2>> /dev/null`
      # if extited correctly start to parse the output
      if $?.exited? and $?.exitstatus == 0
        virtwho_print_output = virtwho_print_output.chop!
        puts_debug "virt-who --print output:", virtwho_print_output
        puts_standard "Command 'virt-who --print' command run successfully. Starting to parse Hypervisors data. Please be patient."
        # start parsing virt-who --print output
        json_hash = JSON.parse(virtwho_print_output)
        # if raw data of json is valid then start checking retrieved data
        if KatelloAttachSubscription::VirtWhoHelper.validhypervisordata(json_hash)
          # clean raw json_hash from entry without socket and cluster data and store the new hash in @parsed_hypervisors_hash
          @parsed_hypervisors_hash = KatelloAttachSubscription::VirtWhoHelper.cleanhypervisorfromrawvirtwho(json_hash)
          # if parsed_hypervisors_hash isn't empty, set virtwho_data to true so this data can use for rescue socket or cluster data in case satellite API fails to retrieve facts from Satellite
          if not @parsed_hypervisors_hash.empty?
            @virtwho_data = true
          else
            # if parsed hypervisor is empty then no data would be used to recover satellite facts fails
            puts_standard " Hypervisor parsing results from 'virt-who --print' is empty, no data from virt-who would be used."
            @virtwho_data = false
          end
        else
          # if ouput data is invalid then no data would be used to recover satellite facts
          puts_standard "Invalid or empty JSON parsed from virt-who. virt-who data would be ignored."
          @virtwho_data = false
        end
      else

        # decomment if virt-who run as a service to start it and avoid error from virt-who print
        # RHEL 7
        # `systemctl start virt-who`
        # RHEL 5, 6
        # service virt-who start

        puts_standard "FATAL ERROR: something went wrong while running virt-who --print command. Possible fix it's to avoid running virt-who as service"
        exit 5
      end

      # decomment if virt-who run as a service to start it and avoid error from virt-who print
      # RHEL 7
      # `systemctl start virt-who`
      # RHEL 5, 6
      # service virt-who start

    end
    puts_debug "the full hypervisor data from JSON output after using virt-who option is:", @parsed_hypervisors_hash
    if not @options[:usecache]
      # always write the cache file at the end, to be used in the future
      puts_standard "Writing JSON file into cache file #{virtwho_cachefile}"
      json_cache_file = File.open(virtwho_cachefile,"w") do |f|
        f.write(JSON.pretty_generate(json_hash))
      end
    end
  end

  # starting retrieve hypervisor data from Satellite API
  # searching if empty-hypervisor or cluster density options
  hypervisors_collection = []
  if @options[:emptyhypervisor] or @options[:density]
    puts_standard "Starting retrieving hypervisor data. Please be patient."
    hypervisors_list = []
    # fetch all the result searching hosts using 'hypervisor=true' as filter
    hypervisors_list = fetch_all_results(:hosts, :index, {:search => "hypervisor=true"})
    puts_verbose "Start retrieving full data for every hypervisors"
    # loop all retrieved hypervisor
    hypervisors_list.each_with_index do |system, currentcount|
      puts_verbose "Current hypervisor #{currentcount+1}/#{hypervisors_list.count}: #{system['name']} (#{system['id']})"
      # retrieve full data for every hypervisor found
      api_error = false
      sys, api_error = apiCall(:hosts, :show, { :id => system['id'], :fields => 'full' }, false)
      if api_error
        puts_error "  ERROR: Hypervisor '#{system['name']}' not found. Skipping"
        next
      end
      if @options[:virtwho] and @virtwho_data
        puts_verbose "adding virt-who data to #{sys['name']}"
        sys = KatelloAttachSubscription::VirtWhoHelper.merge_system_virtwho(sys, @parsed_hypervisors_hash, @options[:org])
      end
      hypervisors_collection.push(sys)
    end
    puts_standard "Collecting hypervisor data completed successfully"
    puts_debug "Hypervisor collected:", hypervisors_collection
  end

  # start checking 'density' of cluster
  if @options[:density]
    puts_standard "Starting checking cluster density"
    puts_debug "use of virt-who enabled, if Satellite fails ise its data"
    # sanity check, if hypervisor::cluster is not found in facts dictionary add it by searching in virt-who data
    # hypervisor::cluster guessed as possible name as cpu.cpu_socket(s) from virt-who is encoded cpu::cpu_socket(s) in Satellite Facts API
    puts_verbose "Start sanity check of hypervisors data"
    # initialize cluster hash dictionary for storing all cluster density data
    cluster_hash = {}
    # loop all the hypervisor founded in API call
    hypervisors_collection.each_with_index do |system, currentcount|
      puts_verbose "Checking cluster of #{system['name']} #{currentcount+1}/#{hypervisors_collection.count}"
      # if field hypervisor::cluster is present and setted skip recovery phase
      if system.has_key?('facts') and system['facts'].is_a?(Hash) and system['facts'].has_key?('hypervisor::cluster') and system['facts']['hypervisor::cluster']
        puts_debug "Hypervisor cluster of #{system['name']} is #{system['facts']['hypervisor::cluster']}"
      else
        puts_verbose "No Hypervisor cluster data found in Satellite for #{system['name']}. Marking with 'nil' as default"
        # saving cluster name as nil
        system.merge!({"facts"=>{'hypervisor::cluster'=>'nil'}})
      end
      # save in the hypervisor data with cluster saved
      @clustered_hypervisor_list.push(system)
    end
    puts_debug "Full clustered hypervisor data", @clustered_hypervisor_list
    # start counting guest and hosts for every cluster
    puts_verbose "Complete retrieving cluster data of all Hypervisor. Starting counting Hosts and Guests."
    ccluster_hash = {}
    # loop all the clustered hypervisor
    @clustered_hypervisor_list.each_with_index do |clu_hypervisor, index|
      hname = clu_hypervisor['facts']['hypervisor::cluster']
      hsocket = 1
      if clu_hypervisor['facts'].has_key?('cpu::cpu_socket(s)')
        hsocket = clu_hypervisor['facts']['cpu::cpu_socket(s)'].to_i
      end
      # if no cluster are already present in ccluster dict, with all the data, create the new entry
      if not ccluster_hash.has_key?(hname)
        ccluster_hash[hname] = {'hosts' => 0, 'guests' => 0, 'socket' => 0, 'els_guests' => 0}
      end
      # set the value of hosts and guests found in hypervisor entry
      ccluster_hash[hname]['hosts'] += 1
      ccluster_hash[hname]['guests'] += clu_hypervisor['subscription_facet_attributes']['virtual_guests'].count
      ccluster_hash[hname]['socket'] += hsocket
      # getting guests data of the hypervisor searching for els
      search_options = "hypervisor_host=virt-who-#{clu_hypervisor['name']}-#{@options[:org]} and organization_id=#{@options[:org]}"
      guests_lists = fetch_all_results(:hosts, :index, {:search => search_options})
      # looping to check which guests need ELS
      guests_lists.each do |single_guest|
        single_guest_os = single_guest['operatingsystem_name'].gsub(/[^\d.]/,'')
        if KatelloAttachSubscription::HostMatcher.match_version(@options[:elsosversion], single_guest_os)
          ccluster_hash[hname]['els_guests'] += 1
        end
      end
      # append guest of hypervisor to guest report, passing clu_hypervisor as guests are present in subscription_facet_attributes dict
      collectguestdata(clu_hypervisor, guests_lists)
    end

    # 'print' in the csv file the guest report
    printguestreport()

    puts_debug "All cluster hosts / guests count data:", ccluster_hash
    # set variable to save for every cluster:
    # index, name, number of hosts and number of guests
    total_hosts_ok = 0
    total_hosts_bad = 0
    total_guests_ok = 0
    total_guests_bad = 0
    total_cluster_ok = 0
    total_cluster_bad = 0
    dict_index = 0
    # list of all csv data to write in the file
    csvcluster = []
    # loop all the counted cluster
    ccluster_hash.each do |key, dict|
      # key is the name of the cluster
      dict_name = key
      # dict the hash with all the data about it as number of hosts and guests
      dict_hosts = dict['hosts']
      dict_guests = dict['guests']
      dict_socket = dict['socket']
      dict_els_guests = dict['els_guests']

      # divide guests by number of sockets hists divided by 2
      dict_ratio = dict_guests.to_f / (dict_socket.to_f / 2)
      # round to the first 2 decimal digit
      dict_ratio = dict_ratio.round(2)

      # divide guests by number of sockets hists divided by 2
      dict_els_ratio = dict_els_guests.to_f / (dict_socket.to_f / 2)
      # round to the first 2 decimal digit
      dict_els_ratio = dict_els_ratio.round(2)

      @cluster_data.push({"cluster_name" => dict_name, "cluster_socket" => dict_socket, "cluster_hosts" => dict_hosts, "cluster_guests" => dict_guests, "cluster_ratio" => dict_ratio, "cluster_els_guests" => dict_els_guests, "cluster_els_ratio" => dict_els_ratio})

      dict_state = ""
      # if ratio is >= densityvalue (default 5) add cluster to the high density ones which has to be subscribed with VDC
      if dict_ratio >= @options[:densityvalue].to_f
        dict_state = 'OK'
        # add to the global count of hosts and guests that are in high density cluster
        total_hosts_ok += dict_hosts
        total_guests_ok += dict_guests
        total_cluster_ok += 1
        # add the cluster name in full_cluster that represent the list of high density cluster
        if dict_name != 'nil' and dict_name != 'none'
          @full_cluster.push(dict_name)
        end
      else
        # else if it's lower mark status as ERROR (light density) and remove vdc subscription to this cluster
        dict_state = 'ERROR'
        if dict_ratio == 0
          dict_state = 'OK'
        end
        # add to the global count of hosts and guests that are in light density cluster
        total_hosts_bad += dict_hosts
        total_guests_bad += dict_guests
        total_cluster_bad += 1
        # add the cluster name in empty_cluster that represent the list of light density cluster
        if dict_name != 'nil' and dict_name != 'none'
          @empty_cluster.push(dict_name)
        end
      end
      # add all the processed variables to cluster row for the CSV file
      cluster_row = {}
      cluster_row['index'] = dict_index
      cluster_row['name'] = dict_name
      cluster_row['socket'] = dict_socket
      cluster_row['hosts'] = dict_hosts
      cluster_row['guests'] = dict_guests
      cluster_row['ratio'] = dict_ratio
      cluster_row['els_guests'] = dict_els_guests
      cluster_row['els_ratio'] = dict_els_ratio
      cluster_row['state'] = dict_state
      csvcluster.push(cluster_row)
      dict_index += 1
    end

    puts_verbose "Retrieve cluster data successfully"
    puts_debug "", csvcluster
    puts_verbose "Start write file #{@options[:densityfile]} with cluster density"
    # write the CSV data in :densityfile, data separated with ; to avoid mismatch with , or . for decimal value
    CSV.open(@options[:densityfile], "wb", {:col_sep => ";"}) do |csv|
      # header of csv
      csv << ["Index","Cluster Name","Total Socekt","Hosts","Guests","Ratio","State","ELS Guests","ELS Ratio"]
      # print for last the host without cluster (none) or no rescue data in it (nil)
      none_index = -1
      nil_index = -1
      # first search for it and save it in none_index and nil_index
      csvcluster.each do |cluster_row|
        if cluster_row['name'] == 'none'
          none_index = cluster_row['index'].to_i
          next
        end
        if cluster_row['name'] == 'nil'
          nil_index = cluster_row['index'].to_i
          next
        end
        # if current cluster isn't nil or none write in the csv file
        csv << [cluster_row['index'],cluster_row['name'],cluster_row['socket'],cluster_row['hosts'],cluster_row['guests'],cluster_row['ratio'],cluster_row['state'],cluster_row['els_guests'],cluster_row['els_ratio']]
      end
      # if none cluster are present report it
      if none_index > -1
        none_cluster = (csvcluster.select {|clstr| clstr['name'] == 'none'}).first
        # none cluster => cluster data not found in Satellite and 'virt-who --print' hypervisor entry found but no cluster data present
        none_string = "NONE: cluster data not found in Satellite and 'virt-who --print' hypervisor entry found but no cluster data present"
        csv << [none_cluster['index'],none_string,none_cluster['socket'],none_cluster['hosts'],none_cluster['guests'],none_cluster['ratio'],none_cluster['state'],none_cluster['els_guests'],none_cluster['els_ratio']]
      end
      # if nil cluster are present report it
      if nil_index > -1
        nil_cluster = (csvcluster.select {|clstr| clstr['name'] == 'nil'}).first
        # nil cluster => cluster data not found in Satellite or/and 'virt-who --print' hypervisor entry not found
        nil_string = "NIL: cluster data not found in Satellite or/and 'virt-who --print' hypervisor entry not found"
        csv << [nil_cluster['index'],nil_string,nil_cluster['socket'],nil_cluster['hosts'],nil_cluster['guests'],nil_cluster['ratio'],nil_cluster['state'],nil_cluster['els_guests'],nil_cluster['els_ratio']]
      end
      # add also a global count of OK and ERROR cluster with their count
      csv << [""]
      csv << [""]
      csv << ["","","Total", "OK Cluster", total_cluster_ok, "OK Hosts", total_hosts_ok, "OK Guests", total_guests_ok]
      csv << ["","","Total", "ERR Cluster", total_cluster_bad, "ERR Hosts", total_hosts_bad,"ERR Guests", total_guests_bad]
    end

    puts_standard "Density check of cluster completed. Saved in #{@options[:densityfile]}"
    # add nil and none as cluster name in the empty cluster list
    @empty_cluster.push('nil')
    @empty_cluster.push('none')
    puts_debug "List of cluster with full hypervisor", @full_cluster
    puts_debug "List of cluster with empty hypervisor", @empty_cluster
    puts_debug "Full cluster data", @cluster_data
  end

  # before attaching subscription to hosts, check if empty hypervisors with valid subscription are present
  # if they are present remove their subscriptions to free subscription "slot"
  if @options[:emptyhypervisor]
    puts_standard "Starting empty hypervisor subscription removal."
    # if are present hypervisors to be removed then start checking their state
    if not hypervisors_collection.empty?
      # get the total number of hypervisors
      remove_total = hypervisors_collection.count
      puts_verbose "Found #{remove_total} hypervisors."
      puts_standard "Start checking if empty hypervisor are present to remove."
      hypervisors_collection.each_with_index do |system, currentcount|
        puts_verbose "Current founded hypervisor #{currentcount+1}/#{remove_total}: #{system['name']} (#{system['id']})"
        # check if almost 1 virtual_guest is present on subscription_facet_attributes
        # if system["subscription_facet_attributes"]["virtual_guests"].count > 0
        if hypervisor_has_guests(system)
          # if present skip, we must remove subscritions only from empty hypervisor
          puts_verbose "Skipping #{system["name"]} as virtual guest count is #{system["subscription_facet_attributes"]["virtual_guests"].count}"
          next
        end
        # if no guests present, retrieve all subscription data from that hypervisor
        remove_all_subs(system)
      end
    else
      puts_verbose "No empty hypervisor with valid subscription found."
    end
  end
end

# function that manage subscription status of one host
def subsupdate()
  # initialize variables
  @default_type = nil
  @subs_count = {}
  @detailed_report = []
  systems = nil
  hosts_data = []
  hosts_details_data = {}

  # Fill systems array from API of satellite. Check for cache usage.
  systems = fetch_all_systems

  puts_standard "Starting host subscription assignment"

  # Uncomment for report start of subscriptiobn time
  # STDERR.puts "Start Sub Time: #{Time.now}"

  # if the concurrency options isn't setted subscribe all the founded systems
  if not @options[:concurrency]
    subscribe_hosts(systems)
  else
    # create subscriptions "semaphore" for ensure lock
    create_subscription_queue
    threads_list = []
    # iterate all the collections of founded systems and create the thread that subscribe the hosts set
    systems.each do |thread_name, thread_hosts|
      # spawn the array of threads
      threads_list.push( Thread.new {subscribe_hosts(thread_hosts, thread_name)} )
    end
    # wait all the thread to be finished
    threads_list.each { |thr| thr.join; @current_thread -= 1 }
  end

  # Uncomment for report end of subscription time
  # STDERR.puts "  End Sub Time: #{Time.now}"

  # writing report of subscription usage counted by the script
  if @options[:subreport]
    puts_standard "Writing report of counted subs"
    printsubsreport()
  end

  puts_standard "Subscription attaching process ended."
  if not @options[:usecache]
    cachefile = @options[:cachefile].to_s + "_org" + @options[:org].to_s
    # always write the cache file at the end, to be used in the future
    puts_standard "Writing YAML file into cache file #{cachefile}"
    # File.open(cachefile, 'w') {|f| f.write(YAML.dump({'systems' => systems, 'system_details' => system_details, 'subs' => @yaml[:subs]})) }
    File.open(cachefile, 'w') {|f| f.write(YAML.dump({'systems' => systems, 'subs' => @yaml[:subs]})) }
  end

end

# function that subscribe the set of passed hosts
def subscribe_hosts(systems, thread_name = nil)
  if @options[:concurrency]
    puts_standard "Started Thread #{Thread.current.object_id}"
  end
  systemstotal = systems.count
  # cycle for each system found
  systems.each_with_index do |system, currentcount|
    puts_verbose "Current system #{currentcount+1}/#{systemstotal}: #{system['name']} (#{system['id']})"
    # if the hosts is already checked skip to avoid double count
    if @checked_hosts.count(system['id']) > 0
      puts_verbose "host #{system['name']} is already checked. Skip to next host"
      next
    end
    assignsubs(system)
  end
end

def assignsubs(system)
  # initialize variable
  req = nil
  has_desired_sub = nil
  desired_sub = nil
  desired_sub_hash = nil
  desired_type = @default_type
  remove_other = true
  remove_subs = []
  keep_subs = []
  auto_attach = false
  keep_virt_only = false
  virtual_host = nil
  desired_quantity = 1
  sys_socket = 1
  hypervisor_found = false
  system_type = ""
  this_system_cluster = ""

  skip_host = false
  has_derived_sub = false

  subs = {}
  sys = nil
  skip_report = false
  sub_counted = []

  # add to array system the name of the system itself taken from id
  puts_verbose "Start assigning subscriptions to #{system['name']}"
  @checked_hosts.push(system['id'])

  # get detail for the current system to be checked.
  puts_debug("detail of the current system to be checked:", system)
  api_error = false
  sys, api_error = apiCall(:hosts, :show, {:id => system['id'].to_i, :fields => 'full'}, false)
  # if api call return error, skip
  if api_error
    puts_error "   ERROR: Host #{system['name']} full api data not found. Skipping."
    return
  end
  # if no host details are found from the api, skip
  if sys.count <= 0
    puts_standard "  WARNING: System name '#{system['name']}' not found. Is cache in use? Skipping."
    return
  end
  # if host isn't registered by subscription manager for anyone reason, skip
  if not sys.has_key?('subscription_facet_attributes')
    puts_verbose "Skipping #{sys['name']} as it isn't registered with subscription manager"
    # next
    return
  end

  # if requested, enable or disable the auto-heal process on the host:
  # if available, the hosts attach subscriptions that cover installed products
  # if the options is different from "noop" act
  if @options[:auto_heal] != "noop"
    # autoheal setted to false, if the option is setted to enable set to true
    autoheal_value = false
    if @options[:auto_heal] == "enable"
      autoheal_value = true
    end
    # params taken by satellite apidoc: :id => which hosts, :hosts hash of the api data to update
    params = {:id => system["id"], :host => {:subscription_facet_attributes => {:autoheal => autoheal_value} } }
    if not @options[:noop]
      puts_standard "#{@options[:auto_heal]} auto-heal for #{system["name"]}"
      apiCall(:hosts, :update, params, false)
    else
      puts_standard "[noop]: #{@options[:auto_heal]} auto-heal for #{system["name"]}"
    end
  end

  # add cluster data to the host
  if @options[:virtwho] and @virtwho_data
    puts_verbose "adding virt-who data to #{sys['name']}"
    add_cluster_data(sys)
  end
  puts_debug "'#{system['name']}' id #{system['id']} :hosts api data:", sys

  # check if the type requested match the host one
  system_type = KatelloAttachSubscription::FactAnalyzer.system_type(sys, sys['facts'])
  # for each item in yaml extract sub
  puts_debug "YAML dump with all definitions for the current system", @yaml

  # Collecting and checking the subscription for the hosts
  @yaml[:subs].each do |sub|
    # if "type" has been specified on yaml file check if match.
    # the default is to check on "Hypervisor"
    # if DO NOT match, skip to next sub
    # fixme: can't find this detail in new API
    if sub.has_key?('type')
      unless KatelloAttachSubscription::HostMatcher.match_type(sub['type'], system_type)
        puts_verbose "Skipping '#{system['name']}' as system type '#{system_type}' is different from desired '#{sub['type']}'"
        next
      end
    end
    # check if sub shall be skipped based on hostname, type and facts
    next if KatelloAttachSubscription::HostMatcher.skip_sub?(sys, sub, @options)

    # extract the (possible) virtual_host
    if sub.has_key?('virtual_host')
      virtualhostregex = Regexp.new(sub['virtual_host'])
    else
      virtualhostregex = nil
    end
    # test all the facts
    puts_verbose "Start testing facts value for #{sys['name']}"
    fact_test_passed = KatelloAttachSubscription::HostMatcher.match_host(sys, sub)
    unless fact_test_passed
      puts_verbose "Host #{sys['name']} doesn't pass facts test. Skip to the next sub entry."
      next
    else
      puts_verbose "Host #{sys['name']} pass fact test. Proceed to attach sub."
    end
    # check the value of use_derived in the sub entry
    use_derived = false
    if sub.has_key?('use_derived')
      use_derived = sub['use_derived']
      if use_derived
        puts_debug "use_derived set to #{use_derived}"
      end
    end

    # if the server is empty and the emptyhypervisor option is setted check if we need to skip the host
    if @options[:emptyhypervisor] and system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
      skip_host ||= !hypervisor_has_guests(sys)
    end

    derived_sub = {}
    attachable_subs = []
    # if system is a guest and density option is on, check if use_derived is true
    if system_type == KatelloAttachSubscription::FactAnalyzer::GUEST and use_derived # and @options[:density]
      # if so, fetch the stack-derived sub available for that host and replace the one in sub_parsing
      puts_verbose "System #{system['name']} is a Guest and desire stack-derived sub, search for it"
      subfiltertype = "STACK_DERIVED"
      api_error = false
      attached_sub_response, api_error = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id']}, false)
      if api_error
        puts_standard "   ERROR: Unable to retrieve subscription data for host #{system['id']} #{system['name']}. Skipping to next host"
        next
      end
      # iterate all the results checking if there are a derivated sub (vdc)
      attached_sub_response['results'].each do |attached_sub|
        if attached_sub['type'] == subfiltertype
          puts_debug "Sub #{attached_sub['cp_id']} is #{subfiltertype}"
          has_derived_sub = true
        end
      end
      # fetch all the attachable subscription for the current hosts
      attachable_subs = fetch_all_results(:subscriptions, :index, {:available_for => "host", :host_id => system['id']})
      # if the lookup has given no results at all, no subscriptions has to be added
      if attachable_subs.empty?
        puts_standard "    Subscription parsing results of search string '#{subscription_item}' is empty, not adding any subscription"
        next
      end
      puts_debug "retrieved subscriptions", attachable_subs
      # if empty, so zero results, this will be simply skipped
      attachable_subs.each do |single_sub|
        puts_debug "subscription detail for subscription #{single_sub['cp_id']}:"
        # check if sub isn't stack_derived
        if single_sub['type'] != subfiltertype
          # if the filter do not match, skip to next subscription
          puts_debug "Skipping '#{single_sub['cp_id']}' as system type '#{single_sub['type']}' is different from desired '#{subfiltertype}'"
          next
        end
        # create product_id key in the derived_sub dictionary if product_id is not yet present in it
        if not derived_sub.has_key?(single_sub['product_id'])
          derived_sub[single_sub['product_id']] = []
        end
        # the entry that will be created would be "RH00271" => "0E376C21A5CB726DC23C544942608656"
        derived_sub[single_sub['product_id']].push(single_sub['cp_id'])
      end
      if derived_sub.empty?
        puts_verbose "No sub available to be attached for #{system['name']}"
      else
        # set change sub to true will attach the derivated one from
        has_derived_sub = true
        # add the remaining product to attach searching for hypervisor in @desired_product
        if sys['subscription_facet_attributes']['virtual_host']
          guest_hypervisor = sys['subscription_facet_attributes']['virtual_host']['name']
          puts_verbose "Adding product for #{sys['name']} that aren't derivable on #{guest_hypervisor}"
          # if the hypervisors which run the vm has subscriptions grab them
          if @desired_product[guest_hypervisor]
            derived_products = @desired_product[guest_hypervisor]
            sub['sub_parsed'].each do |product, parsed_product|
              if derived_products.count(product) == 0
                derived_sub[product] = parsed_product
              end
            end
          else
            puts_verbose "No non derivable product added for #{sys['name']}"
          end
        end
      end
      puts_debug "Subscription to attach at guest #{system['name']}", derived_sub
    end

    # starting to get the correct number of socket to calculate the correct number of subscription to attach
    puts_debug "Checking the number of socket for #{sys["name"]}"
    # if the number of socket is setted, we can find the value from cpu::cpu_socket(s)
    if sys.has_key?("facts") and sys["facts"].is_a?(Hash) and sys["facts"].has_key?("cpu::cpu_socket(s)")
      # if the field is present check if it's a valid entry or not, if not exit with error
      if sys["facts"]["cpu::cpu_socket(s)"].to_i > 0
        # set sys_socket to the value of cpu::cpu_socket(s)
        sys_socket = sys["facts"]["cpu::cpu_socket(s)"].to_i
        puts_debug "Setting sys_socket to #{sys_socket} for #{sys["name"]}"
      else
        puts_standard "   FATAL ERROR: The number of socket for #{sys["name"]} it's equal or lower then 0."
        exit 5
      end
    else
      sys_socket = 1
      puts_debug "No cpu sockets entry found for #{sys['name']}, assigned 1 by default"
    end
    puts_debug "System '#{system['name']}' in scope, proceeding with assignment of variables"
    # set the desidered subscription to be associated
    sub_layer = sub['sub_layer'] || "stop_parsing"
    puts_debug "Sub Layer of this sub entry: #{sub_layer}"
    if sub.has_key?('sub_parsed')
      if has_derived_sub
        desired_sub_hash = KatelloAttachSubscription::Utils.merge_subs(desired_sub_hash, derived_sub, sub_layer)
      else
        desired_sub_hash = KatelloAttachSubscription::Utils.merge_subs(desired_sub_hash, sub['sub_parsed'], sub_layer)
      end
    end
    # if "remove_other" has been set, set the flag
    if sub.has_key?('remove_other')
      remove_other = sub['remove_other']
    end
    # if "remove_subs" has been set, use it
    if sub.has_key?('remove_subs')
      remove_subs = sub['remove_subs']
    end
    # if "keep_subs" has been set, use it
    if sub.has_key?('keep_subs')
      keep_subs = sub['keep_subs']
    end
    # if "auto_attach" has been set, set the flag
    if sub.has_key?('auto_attach')
      auto_attach = sub['auto_attach']
    end
    # if "keep_virt_only" has been set, set the flag
    if sub.has_key?('keep_virt_only')
      keep_virt_only = sub['keep_virt_only']
    end

    # if the system is found, stop cyclyng over yaml,
    if sub_layer == "stop_parsing"
      break
    end
  end

  # if the hosts has nothing to do simply return from the function
  if skip_host
    puts_verbose "Skipping #{system['name']} as host doesn't need nothing more to do."
    if system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
      # but first, manage the hypervisor guests subscription
      subscribe_guest(system['name'])
    end
    return
  end
  # check if one or more hosts need a subscription
  puts_debug "desired_sub_hash value", desired_sub_hash
  # if the current host is an hypervisor add the parsed subscriptions to the hash containing all the "dervable" product
  if system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
    add_hypervisor_product(system['name'], desired_sub_hash)
  end
  # if there are something to attach
  if desired_sub_hash or not remove_subs.empty?
    # maybe we do not have any subs to add, but remove_subs was not empty
    if not desired_sub_hash
      desired_sub_hash = {'none' => []}
    end
    # if the options for cleaning subscriptions is setted start removing "duplicated" attached subscription
    if @options[:clean_sub]
      api_error = false
      cleanable_sub, api_error = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id'], :per_page => 100}, false )
      clean_same_product(desired_sub_hash, cleanable_sub["results"], system, system_type, sys_socket)
    end
    puts_debug "Checking subscription for #{system['name']} (#{system['id']})"
    has_desired_sub_hash = {}
    # for every product (hash key in yaml) check the desired subs
    desired_sub_hash.each do |product, desidered_product_sub_array|
      puts_debug "in the desired_sub_hash #{desidered_product_sub_array}"
      has_desired_sub = false
      # check the current associated subscription to this system
      api_error = false
      req, api_error = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id'], :per_page => 100}, false )
      if api_error
        puts_standard "  WARNING: Subscription problem -- unable to retrieve subscription for host #{system['id']} #{system['name']}"
        next
      end
      # check a single subscription in the array
      req['results'].each do |sub|
        # check if the found cp_id is in the list of the current product, if it is, our job here is done
        if desidered_product_sub_array.include?(sub['cp_id'])
          total_subscriptions = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, sub)
          puts_standard "  #{system['name']} need #{total_subscriptions} subscriptions for sub #{sub['id']}"
          subscriptions_needed = total_subscriptions.to_i - sub['quantity_consumed'].to_i
          # if the options for the subscription report is setted and the subscription type isn't vdc start counting
          if @options[:subreport] and not sub['type'] == "STACK_DERIVED"
            # count the sub to add, if not just present
            puts_debug "Current counted sub: #{sub_counted}"
            # if not present, call addtototalsubneeded to add the count of subs
            if not sub_counted.include?(sub['name'])
              skip_report = true
              addtototalsubneeded(system['name'], sub['name'], total_subscriptions)
              # add to the subs counted
              sub_counted.push(sub['name'])
            else
              # if just counted don't do nothing
              puts_debug "Skipping count as sub #{sub['name']} is just present"
            end
          end
          # if stack derived subs are to be attached skip the part of cleaning
          if not has_derived_sub
            # check sub needed = 0
            if subscriptions_needed == 0
              puts_standard "  subscription #{sub['cp_id']} for #{product} product is already attached to #{system['name']}"
            else
              # if subscriptions_needed != 0 then attached sub to the host consumed_quantity is < or > of the correct one.
              if subscriptions_needed < 0
                puts_standard "  WARNING: Subscription #{sub['id']} attached #{sub['quantity_consumed']} that is > of quantity needed: #{total_subscriptions}, sub would be removed and reattached"
              else
                puts_standard "  subscription #{sub['cp_id']} for #{product} product is attached to #{system['name']}, but still need to consume #{subscriptions_needed} token, sub would be removed and reattached"
              end
              # if kas run in concurrency, lock the subscription
              if @options[:concurrency]
                lock_subscription(sub)
              end
              # check if sub available sub are >= of the one needed as
              # - if sub_needed > 0 then we need to see if (qty attached + qty to attach) < qty available
              if sub['available'] >= subscriptions_needed
                # set subscriptions_needed to the total entitlments as current sub is to be removed and reattached consuming total_subscriptions sub.
                subscriptions_needed = total_subscriptions
                if not @options[:noop]
                  puts_standard "  removed #{sub['id']} - #{sub['cp_id']}"
                  # first, remove the subscriptions with the wrong entitlement
                  api_error = false
                  dummy_result = nil
                  dummy_result, api_error = apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id']}]}, false)
                  if api_error
                    puts_error "WARNING: Unable to remove subscription #{sub['id']} from #{system['name']} - ID: #{system['id']}"
                  end
                  puts_standard "  reattached #{sub['id']} - #{sub['cp_id']}"
                  # then, reattach the subscription with the correct value
                  api_error = false
                  dummy_result = nil
                  dummy_result, api_error = apiCall(:host_subscriptions, :add_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id'], :quantity => subscriptions_needed}]}, false)
                  if api_error
                    puts_error "WARNING: Unable to attach subscription #{sub['id']} to #{system['name']} - ID: #{system['id']}"
                  end
                else
                  puts_standard "  [noop]: #{sub['id']} - #{sub['cp_id']} would be removed and reattached with correct quantity: #{subscriptions_needed}"
                end
              else
                puts_standard " Skipping fixing the subscription of #{sub['id']} for #{system['name']} because #{subscriptions_needed} requested but #{sub['available']} available"
              end
              # if kas run with concurrency unlock the subscription
              if @options[:concurrency]
                unlock_subscription(sub)
              end
            end
          end
          has_desired_sub = true
        # else, if this is not among the desired subscriptions (ALL of them, not only the current product)
        # and remove_other is set, remove this subscription to the system
        elsif sub['cp_id'] != nil and not desired_sub_hash.flatten(2).include?(sub['cp_id']) and (remove_other or remove_subs.include?(sub['cp_id'])) and not (keep_virt_only and sub.has_key?('virt_only') and sub['virt_only']) and not keep_subs.include?(sub['cp_id']) and sub['type'] != "STACK_DERIVED"
          puts_standard "  removing subscription #{sub['cp_id']} from system #{system['name']}"
          if not @options[:noop]
            api_error = false
            dummy_result = nil
            dummy_result, api_error = apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => sub['id']}]}, false)
            if api_error
              STERR.puts "WARNING: Unable to remove subscription #{sub['id']} from #{system['name']} - ID: #{system['id']}"
            else
              puts_standard "  removed"
            end
          else
            puts_standard "  [noop] removed"
          end
        end
      end
      # if all of the subscriptions marked for this product is missing, mark it to be added
      if not desidered_product_sub_array.empty? and not has_desired_sub
        puts_standard "  Subscription on host #{system['name']} for product " + product.to_s + " currently missing. Set for the attach."
        has_desired_sub_hash[product] = desidered_product_sub_array
      end
    end
    puts_debug "has_desired_sub_hash:", has_desired_sub_hash
    # if the system do not has proper subscritions, attach it
    if has_desired_sub_hash
      # cycle for each product
      has_desired_sub_hash.each do |product, desired_subs_hash|
        sub_attached = false
        # cycle for each subscription
        desired_subs_hash.each do |desired_sub|
          puts_debug "current subscription to be chekced", desired_sub
          # if subs[desired_sub] is false, retrieve the current subscription detail
          response = fetch_all_results(:subscriptions, :index, {:search => "id=#{desired_sub}", :organization_id => @options[:org]})
          subs[desired_sub] = response[0]
          if not subs[desired_sub]
            puts_error "  ERROR: Unable to retrive subscription for #{desired_sub}"
            next
          end
          # calculate the desired quantity of entitlment to be attached
          desired_quantity = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, subs[desired_sub])
          puts_standard "   The number of subscriptions needed for #{desired_sub} (id: #{subs[desired_sub]['id']}) is of #{desired_quantity}"
          # if kas run with concurrency, lock the subscription resource
          if @options[:concurrency]
            lock_subscription(subs[desired_sub])
          end
          # if there are not enough available subscriptions check the next available
          if desired_quantity > subs[desired_sub]['available'].to_i and subs[desired_sub]['quantity'].to_i != -1
            puts_standard "   Cannot add subscription #{desired_sub} (id: #{subs[desired_sub]['id']}): only #{subs[desired_sub]['available']} available, but #{desired_quantity} requested"
            if @options[:concurrency]
              # release desired resources as we don't need it anymore if number of free entitlment are less then the required
              unlock_subscription(subs[desired_sub])
            end
            next
          end
          if @options[:subreport] and not desired_quantity == 0
          # count the sub to add, if not present
            puts_debug "Current counted sub:", sub_counted
            # if not present, call addtototalsubneeded to add the count of subs
            if not sub_counted.include?(subs[desired_sub]['name'])
              skip_report = true
              addtototalsubneeded(system['name'], subs[desired_sub]['name'], desired_quantity)
              # add to the subs counted
              sub_counted.push(subs[desired_sub]['name'])
              sub_attached = true
            else
              # if already counted don't do nothing
              puts_debug "Skipping count as sub #{subs[desired_sub]['name']} is just present"
            end
          end
          # if requirements are met, add the subscription
          puts_standard "   adding #{desired_sub} for #{product} (id: #{subs[desired_sub]['id']})"
          # fix the number of the available and consumed subscription because this will be retrieved only once
          subs[desired_sub]['available'] -= desired_quantity
          subs[desired_sub]['consumed'] += desired_quantity
          # call the api to attach the subscriptions if :noop option isn't setted
          if not @options[:noop]
            api_error = false
            dummy_result = nil
            # call the api
            dummy_result, api_error = apiCall(:host_subscriptions, :add_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => subs[desired_sub]['id'], :quantity => desired_quantity}]}, false)
            if api_error
              puts_error "  WARNING: Subscription problem -- unable to attach subscription for host #{system['id']} #{system['name']}"
            else
              puts_standard "    Added #{desired_sub} for #{product} in system #{system['name']}"
              # if kas run in concurrency, unlock the subscription resource
              if @options[:concurrency]
                unlock_subscription(subs[desired_sub])
              end
              break
            end
          else
            puts_standard "    [noop] Added #{desired_sub} for #{product} in system #{system['name']}"
            if @options[:concurrency]
              unlock_subscription(subs[desired_sub])
            end
            break
          end
        end

        # if no sub attached but needed, add to the count that you need the first one
        if @options[:subreport] and not desired_quantity == 0
          if not sub_attached
            # set as missing the first desired_subs entry
            sub_missing = desired_subs_hash.first
            missing_hash = subs[sub_missing]
            sub_socket = missing_hash['sockets']
            desired_quantity = KatelloAttachSubscription::Utils.needed_entitlement(system_type, sys_socket, missing_hash)
            puts_verbose "#{system['name']} didn't attach any #{product} sub, set that need #{sub_missing}"
            addtototalsubneeded(system['name'], missing_hash['name'], desired_quantity)
            skip_report = true
          end
        end
      end
    end
  else
    # if the hosts hasn't any sub to be attached and the options :clean_sub is enabled remove all the attached subscriptions to the hosts
    if @options[:clean_sub]
      puts_standard "Server #{system['name']} have no subscription to be attached from parsing. Removing all of them"
      remove_all_subs(system)
    end
  end

  # if auto-attach flag is set in YAML perform auto-attach for this hosts
  if auto_attach
    puts_standard " auto-attaching subs to system #{system['name']}"
    if not @options[:noop]
      api.resource(:host_subscriptions).call(:auto_attach, {:host_id => system['id']})
      if @options[:subreport]
        # call function that get all the sub consumed and count only physical sub as stacked-derived are for unlimited guest
        addspecialsubtocount(system)
      end
    else
      puts_standard " [noop] auto-attached"
    end
  end
  # if the current host is an hypervisor, check its guests to avoid LONG "subscriptions" blackout
  if system_type == KatelloAttachSubscription::FactAnalyzer::HYPERVISOR
    subscribe_guest(system['name'])
  end
end

# add to the dictionary of requested product the product to be removed because derived
def add_hypervisor_product(hypervisor_name, requested_sub)
  if @desired_product.has_key?(hypervisor_name)
    return
  end
  if @options[:verbose]
    puts_standard "  VERBOSE: Adding desired product for hypevisor #{hypervisor_name}"
  end
  if requested_sub and requested_sub.count > 0
    @desired_product[hypervisor_name] = []
    requested_sub.each do |product, product_sub_array|
      @desired_product[hypervisor_name].push(product)
    end
    puts_debug "product added for #{hypervisor_name}"
  else
    puts_verbose "No product to be add on hypervisor list"
  end
end

# subscribe guest after hypervisor update, still wip as to implement new use_derived function
def subscribe_guest(hypervisor_name)
  # fetch the guests of an hypervisor using the special query of "hypervisor_host=<hypervisor>" in the :host :index API call
  search_options = "hypervisor_host=#{hypervisor_name}"
  hypervisor_guests = fetch_all_results(:hosts, :index, :search => search_options)
  # if there are any guests continue, return from the function
  if hypervisor_guests.count > 0
    puts_verbose "Hypervisor has #{hypervisor_guests.count} guests. Subscribing it."
    if not @options[:concurrency]
      # if the :concurrency options is disable simply subscripbe all the guests one by one
      hypervisor_guests.each do |hyp_guest|
        puts_verbose "Assigning subscriptions to #{hyp_guest['name']}"
        assignsubs(hyp_guest)
      end
    else
      # get the number of available thread by removing the number of max thread with the current running ones
      available_thread = @options[:maxthread] - @current_thread
      # if there are 1 or less available thread, assign the subscription in the same thread
      if available_thread <= 1
        puts_verbose "No more free thread for subscribing "
        hypervisor_guests.each do |hyp_guest|
          puts_verbose "Assigning subscriptions to #{hyp_guest['name']}"
          assignsubs(hyp_guest)
        end
      else
        # obtain the number of guests to be subscribed for every thread (chunk_size)
        chunk_size = (hypervisor_guests.count.to_f / available_thread.to_f).ceil
        # get the number of thread to be spawned recalculating it "rounding up" the results
        thread_to_spwan = (hypervisor_guests.count.to_f / chunk_size.to_f).ceil
        puts_debug "Will be spawned #{thread_to_spwan} thread(s) with #{chunk_size} guests"
        # slice the hypervisor guests array in an array of array of guests
        chunk_guests = hypervisor_guests.each_slice(chunk_size).to_a
        guests_thread_list = []
        # iterate over all the chunk of guests and spawn the thread
        chunk_guests.each do |chunk_list|
          @current_thread += 1
          guests_thread_list.push( Thread.new {subscribe_hosts(chunk_list)} )
        end
        # wait the end of all the spawned sub thread
        guests_thread_list.each { |thr| thr.join; @current_thread -= 1 }
        puts_debug "All guests of #{hypervisor_name} are checked"
      end
    end
  else
    puts_verbose "No guests on #{hypervisor_name}. Skipping its guests subscriptions"
  end
end

# remove all the subscriptions from a system
def remove_all_subs(system)
  api_error = false
  # get all the attached sub of an host
  attached_sub, api_error = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system['id'], }, false)
  if api_error
    puts_verbose "Can't retrieve subscriptions for #{system['id']}. Skipping removal of subs."
    return
  end
  # if no sub are attached then exit
  if attached_sub["results"].count <= 0
    puts_verbose "No subscriptions attached to #{system['name']}. Nothing to remove."
    return
  end
  attached_sub['results'].each do |subscription|
    if not @options[:noop]
      api_error = false
      dummy_result = nil
      # get the subscription details and remove them one by one
      dummy_result, api_error = apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => system['id'], :subscriptions => [{:id => subscription['id']}]}, false )
      if not api_error
        puts_standard "  removed subscription ID #{subscription['id']}"
      else
        puts_standard "  WARNING: Problem removing subscription ID #{subscription['id']} from host #{system['name']} - ID #{system['id']}"
      end
    else
      puts_standard "  [noop] removed subscriptions ID #{subscription['id']}"
    end
  end
end

# add additional data from cluster retrieved by --check-density and --virt-who options
def add_cluster_data(sys)
  # add virt-who data to hypervisor
  sys = KatelloAttachSubscription::VirtWhoHelper.merge_system_virtwho(sys, @parsed_hypervisors_hash, @options[:org])
  # add calculated cluster data from --check-density options
  this_system_cluster = 'nil'
  if @options[:density]
    # retrieve cluster name of the hypervisor
    if sys.has_key?('facts') and sys['facts'].has_key?('hypervisor::cluster')
      this_system_cluster = sys['facts']['hypervisor::cluster']
    end
    if this_system_cluster == 'nil'
      sys['facts'] ||= {}
      sys['facts']['hypervisor::cluster'] = this_system_cluster
    end
    puts_debug "system cluster: #{this_system_cluster}"
    # add the data calculated with the :check_density option as facts for every hypervisor that has a valid cluster
    if this_system_cluster != "nil" and this_system_cluster != "none"
      cluster_index = @cluster_data.index{|scluster| scluster['cluster_name'] == sys['facts']['hypervisor::cluster']}
      if cluster_index
        cluster_data = @cluster_data[cluster_index]
        # add the cluster data as facts
        cluster_data.each do |key, value|
          sys['facts'] ||= {}
          key_name = "cluster_data::#{key}"
          sys['facts'][key_name] = value
        end
        puts_debug "All facts after cluster data_facts addition", sys['facts']
      end
    end
  end
end


## MARK: Cluster Data Functions

# collect in @guest_list every guest with its host and cluster that would be print in :guestreportfile
def collectguestdata(hypervisor_hash, guests_list)
  # if has guest start report, if not report as no guest are present for passed hypervisor
  if hypervisor_hash['subscription_facet_attributes']['virtual_guests'].count > 0
    puts_verbose "#{hypervisor_hash['name']} has #{hypervisor_hash['subscription_facet_attributes']['virtual_guests'].count} guests. Start reporting"
    # loop all the guest
    hypervisor_hash['subscription_facet_attributes']['virtual_guests'].each do |guest_data|
      # get os of the guest
      guest_position=guests_list.index{|sguest| sguest['name'] == guest_data['name']}
      if guest_position
        guest_os=guests_list[guest_position]['operatingsystem_name']
      end
      # create hash for every guest with name, hypervisor name and hypervisor cluster
      guest_hash = {}
      guest_hash['name'] = guest_data['name']
      guest_hash['host'] = hypervisor_hash['name']
      guest_hash['cluster'] = hypervisor_hash['facts']['hypervisor::cluster']
      guest_hash['operating_system'] = guest_os
      @guest_list.push(guest_hash)
    end
  else
    puts_verbose "#{hypervisor_hash['name']} has no guests. Skip from report"
    # create hash that set "no guest" as name, hypervisor name and hypervisor cluster
    guest_hash = {}
    guest_hash['name'] = "No Guest"
    guest_hash['host'] = hypervisor_hash['name']
    guest_hash['cluster'] = hypervisor_hash['facts']['hypervisor::cluster']
    guest_hash['operating_system'] = ""
    @guest_list.push(guest_hash)
  end
end

# print in :guestreportfile the report for every record contained in @guest_list which contain hosts and cluster data for a virtual guests
def printguestreport()
  puts_verbose "Printing guest report in #{@options[:guestreportfile]}"
  CSV.open(@options[:guestreportfile], "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Cluster Name", "Hypervisor Name", "Guest Name", "Operative System"]
    @guest_list.each do |guest_data|
      csv << [guest_data['cluster'], guest_data['host'], guest_data['name'], guest_data['operating_system']]
    end
  end
end

# return true if an hypervisor has guest on it, checking from satellite data passed
def hypervisor_has_guests(hostdata)
  has_guests = false
  # check if virtual_guests array in subscription_facet_attributes has elements
  puts_verbose "Checking if #{hostdata['name']} has virtual_guests on it."
  # if virtual_guests array has element on it set has_guest to true
  if hostdata["subscription_facet_attributes"].has_key?("virtual_guests") and hostdata["subscription_facet_attributes"]["virtual_guests"].count > 0
    puts_verbose "#{hostdata["name"]} has #{hostdata["subscription_facet_attributes"]["virtual_guests"].count} guests"
    has_guests = true
  else
    # else set has_guest to false
    puts_verbose "#{hostdata["name"]} has no guests in it"
    has_guests = false
  end
  return has_guests
end


## MARK: Subscription Management Functions

# clean attached subs of the same products from a content-hosts
def clean_same_product (desired_sub_hash, host_subscriptions, host, host_type, host_socket)
  desired_sub_hash.each do |product, desired_product_sub_array|
    puts_standard "Start checking if there are multiple #{product} subscriptions attached to #{host["name"]}"
    remove_subscription = []
    fit_subscription = nil
    # iterate over the passed subscriptions
    host_subscriptions.each do |single_sub|
      sub_count = desired_product_sub_array.count(single_sub["cp_id"]).to_i
      # if the product was already removed or it's a vdc subs do nothing
      if single_sub["type"] == "STACK_DERIVED" or sub_count <= 0
        next
      end
      # if we didn't find yet the fittest sub (the first one that is ok) try to found them
      if not fit_subscription
        # get the number of entitlment that the subs may have
        needed_entitlement = KatelloAttachSubscription::Utils.needed_entitlement(host_type, host_socket, single_sub)
        # get the number of entitlment attached to the host
        attached_entitlement = single_sub["quantity_consumed"]
        if needed_entitlement >= attached_entitlement
          # if the subscriptions use the right quantity of entitlment set as the fit subscription
          fit_subscription = single_sub["cp_id"]
        else
          # else add it to the subs that will be removed
          remove_subscription.push(single_sub["id"])
        end
      else
        # else add it to the subs that will be removed
        remove_subscription.push(single_sub["id"])
      end
    end
    puts_standard "#{product} subscriptions that will be removed"
    p remove_subscription
    # iterate over the subscriptions to be remvoed and removing it
    remove_subscription.each do |subscription|
      if not @options[:noop]
        api_error = false
        dummy_result = nil
        dummy_result, api_error = apiCall(:host_subscriptions, :remove_subscriptions, {:host_id => host['id'], :subscriptions => [{:id => subscription}]}, false )
        if not api_error
          puts_standard "  removed subscription ID #{subscription}"
        else
          puts_standard "  WARNING: Problem removing subscription ID #{subscription} from host #{host['name']} - ID #{host['id']}"
        end
      else
        puts_standard "  [noop] removed subscriptions ID #{subscription}"
      end
    end
  end
end


## MARK: Subscription Report Functions

# add the value of sub passed in sub_quantity to the sub passed in sub_name in subs_count hash
# def addtototalsubneeded(sub_name, sub_quantity)
def addtototalsubneeded(hostname, sub_name, sub_quantity, type = "")
  puts_verbose "Adding #{sub_quantity} to needed quantity of subscription #{sub_name}"
  # if sub_name not exists, add with 0
  if not @subs_count.has_key?(sub_name)
    @subs_count[sub_name] = 0
  end
  # add the count to the sub passed
  @subs_count[sub_name] += sub_quantity
  # added detailed report data
  detailed_entry = {}
  detailed_entry['hostname'] = hostname
  detailed_entry['subname'] = sub_name
  detailed_entry['quantity'] = sub_quantity
  detailed_entry['type'] = type
  @detailed_report.push(detailed_entry)
end

# create the CSV file that report the subscription count
def printsubsreport()
  puts_verbose "Printing subscription status"
  filename="#{@options[:subreportfile]}"
  CSV.open(filename, "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Subscription Name","Expected Entitlement","Entitlement Available","Entitlement Consumed","Entitlement Free", "State"]
    # add the entitlment report
    @subs_count.each do |sub_name, sub_count|
      sub_hash = getsubdetailfor(sub_name)
      count_state = "OK"
      if sub_count.to_i > sub_hash["available"].to_i
        count_state = "ERROR"
      end
      csv << [sub_name, sub_count, sub_hash["available"], sub_hash["consumed"], sub_hash["free"], count_state]
    end
    csv << [""]
    csv << [""]
    # header of the subscription (with IM) report
    csv << ["Subscription Name", "Instance Multiplier", "Expected Subscription", "Subscription Available", "Subscription Consumed", "Subscription Free", "State"]
    @subs_count.each do |sub_name, sub_count|
      sub_hash = getsubdetailfor(sub_name)
      count_state = "OK"
      # retrieve the instance multiplier of the subscription
      instance_multiplier = 1
      if KatelloAttachSubscription::Utils::EXCEPTION_SUB.include?(sub_name)
        instance_multiplier = 2
      end
      # gather the various data to be displayed
      sub_count = (sub_count.to_f/instance_multiplier.to_f).ceil
      sub_available = (sub_hash["available"].to_f/instance_multiplier.to_f).ceil
      sub_consumed = (sub_hash["consumed"].to_f/instance_multiplier.to_f).ceil
      sub_free = sub_available - sub_consumed
      if sub_count > sub_available
        count_state = "ERROR"
      end
      # write in the csv
      csv << [sub_name, instance_multiplier, sub_count, sub_available, sub_consumed, sub_free, count_state]
    end
  end
  # start writing the detailed report of the subscription
  detailedfilename = "#{@options[:detailedsubreportfile]}"
  CSV.open(detailedfilename, "wb", {:col_sep => ";"}) do |csv|
    # header of csv
    csv << ["Server Name", "Expected Subscription", "Expected Entitlement Quantity", "Type"]
    @detailed_report.each do |sub_entry|
      csv << [sub_entry["hostname"], sub_entry["subname"], sub_entry["quantity"], sub_entry["type"]]
    end
  end
end

# get all the subscriptions of the hosts for special case as:
# - hosts that would be auto attached
def addspecialsubtocount(system)
  system_id = system['id']
  attached_subscriptions = []
  # retrieve all the subscription attached
  api_error = false
  response, api_error = apiCall(:host_subscriptions, :index, {:organization_id => @options[:org], :host_id => system_id}, false)
  if api_error
    puts_error "   ERROR: Unknow Error -- Unable to retrieve subscription details for hypervisor #{system_id}"
  end
  # check if data found (API return data successfully)
  if not response.has_key?("total")
    puts_verbose "Skipping Hypervisor as not valid data was retrieved from API"
  else
    # check if total > 0, then loop the result to remove the subscriptions
    if response["total"].to_i > 0
      response["results"].each_with_index do |attached_sub, sub_index|
        puts_verbose "Counting attached subscription #{sub_index+1} / #{response["total"].to_i} - #{attached_sub['id']}"
        addtototalsubneeded(system['name'], attached_sub['name'], attached_sub['quantity_consumed'], attached_sub['type'])
      end
    end
  end
end

# count the total number of subs available, consumed and free
def getsubdetailfor(sub_name)
  detail_hash = {"consumed" => 0, "free" => 0}
  search_params = {"name" => sub_name}
  search_options = KatelloAttachSubscription::Utils.search_args(search_params)
  search_options = 'name="'+sub_name+'"'
  parsed_subscription = fetch_all_results(:subscriptions, :index, {:search => search_options, :available_for => "host"})
  detail_hash["available"] = getavailablesubfor(parsed_subscription)
  detail_hash["consumed"] = getconsumedsubfor(parsed_subscription)
  detail_hash["free"] = getfreesubfor(parsed_subscription)
  return detail_hash
end

# count the total number of subs free to be consumed
def getfreesubfor(parsed_subscription)
  free_subs = 0
  if parsed_subscription.empty?
    puts_standard "    Subscription entry is empty, not counting any free subscription"
    return free_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      puts_debug "Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['available'].to_i < 0
      puts_debug "Skipping #{subscription['id']} as available subs are < 0"
      next
    end
    # add the subs to the total free
    free_subs += subscription['available']
  end
  return free_subs
end

# return the quantity of the consumed subscriptions
def getconsumedsubfor(parsed_subscription)
  consumed_subs = 0
  if parsed_subscription.empty?
    puts_standard "    Subscription entry is empty, not counting any free subscription"
    return consumed_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      puts_debug "Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['consumed'].to_i < 0
      puts_debug "Skipping #{subscription['id']} as consumed subs are < 0"
      next
    end
    # add the subs to the total consumed
    consumed_subs += subscription['consumed']
  end
  return consumed_subs
end

# return the quantity of the consumed subscriptions
def getavailablesubfor(parsed_subscription)
  available_subs = 0
  if parsed_subscription.empty?
    puts_standard "    Subscription entry is empty, not counting any free subscription"
    return available_subs
  end
  # if empty, so zero results, this will be simply skipped
  parsed_subscription.each do |subscription|
    # Check type of sub 'normal'
    if subscription.has_key?('type') and subscription['type'] != 'NORMAL'
      puts_debug "Skipping '#{subscription['cp_id']}' as sub type '#{subscription['type']}' is different from desired 'NORMAL'"
      # if the filter do not match, skip to next subscription
      next
    end
    if subscription['quantity'].to_i < 0
      puts_debug "Skipping #{subscription['id']} as consumed subs are < 0"
      next
    end
    # add the subs to the total available
    available_subs += subscription['quantity']
  end
  return available_subs
end


## MARK: API Functions

# fetch all the hosts reading from the yaml configuration file, if present
def fetch_all_systems
  systems = []
  if @options[:concurrency]
    systems = {}
  end
  cachefile = @options[:cachefile].to_s + "_org" + @options[:org].to_s
  if @options[:usecache]
    puts_standard "Starting host collection from cache. Please be patient."
    cachefile = "#{@options[:cachefile]}_org#{@options[:org]}"
    systems = readfromcache(cachefile, 'systems')
  else
    # no cache wanted
    # Currently there is a BZ opened as is not possible to absolute search hypervisor, physical and guest (BZ1635861)
    # suggested queries to fetch all the systems type (physical, hypervisor, guests) be implemented in the config file are:
    # - facts.virt::host_type = "Not Applicable"
    # - hypervisor = true
    # - facts.virt::is_guest = true
    puts_standard "Starting host collection from API. Please be patient."
    # if :multisearch or concurrency options are enabled, fetch queries from yaml configuration
    if @options[:multisearch] or @options[:concurrency]
      search_data = @yaml[:search]
      search_data.each do |search_data|
        if search_data.is_a?(Hash)
          # if in config file :search is an hash take the value from query key
          search_options = search_data["query"]
        else
          # otherwise take the data as is, as it may be a string
          search_options = search_data
        end
        puts_standard "Searching for Hosts that match #{search_options}"
        if @options[:concurrency]
          # if :concurrency options is enabled put the results of the query in the appropriate "Thread label"
          systems[search_data["thread"]] ||= []
          systems[search_data["thread"]].concat(fetch_all_results(:hosts, :index, {:search => search_options}))
        else
          # otherwise concat the results in the array of systems
          systems.concat(fetch_all_results(:hosts, :index, {:search => search_options}))
        end
      end
      if @options[:concurrency]
        # if :concurrency enabled check that the number of thread that will be spawned is lower then the maxthread
        if systems.count > @options[:maxthread]
          puts_standard "FATAL ERROR: Asked a number of thread greater of the one configured. Check configuration file."
          exit 1
        end
        @current_thread = systems.count
      end
    else
      # if no search options passed collect all the hosts indipendently
      search_options = ""
      puts_standard "Searching for all Hosts in the environment"
      systems = fetch_all_results(:hosts, :index, {:search => search_options})
    end
    # count the hosts retrieved
    hosts_count = systems.count
    puts_standard "Completed hosts collection."
    puts_standard "Hosts entry: #{hosts_count}"
  end
  return systems
end

# call api function to retrieve the list of object passed in resource
def fetch_all_results(resource, action, params)
  page = 0
  req = nil
  results = []
  while (page == 0 or req['results'].length == req['per_page'].to_i)
    # increase page counter
    page += 1
    # get 100 results
    api_error = false
    params.merge!({:organization_id => @options[:org], :page => page, :per_page => 100})
    req, api_error = apiCall(resource, action, params, true)
    # concatenate output - all of the results
    results.concat(req['results'])
  end
  return results
end

# perform an api call checking for error and retry if options is setted
def apiCall(resource, action, params, exiting)
  # if :repeatAPI option isn't setted set as number of try 1, the first call
  if not @options[:repeatAPI]
    @options[:maxstep] = 1
  end
  # flag that say if api returns errors
  api_error = true
  exceptions_list = []
  results = {}
  step = 0
  # call api while there is an error and the retry step is <= then the max try
  while api_error and step <= @options[:maxstep]
    # start the try catch block code
    begin
      # made the api call
      results = @api.resource(resource).call(action, params)
      # if the API response isn't 200 the next line would be ignored, so api_error remove it
      api_error = false
    rescue RestClient::ExceptionWithResponse => exception
      # rescue codeblock that will be executed in case of any api error
      api_error = true
      # increase the number of the step
      step = step + 1
      # add the error details like message and response of the exception
      exceptions_list.push({"time"=> Time.now, "step" => step, "message" => exception.message, "response" => exception.response })
      puts_debug "API #{resource} / #{action} failes for the #{step} time(s)."
      # if :sleepAPI option is enabled wait an incremental time
      if @options[:sleepAPI]
        waiting_time = @options[:sleepTime] * ( @options[:sleepMult].to_f ** (step - 1) )
        puts_debug "waiting #{waiting_time} seconds before repeat API call"
        sleep(waiting_time)
      end
    end
  end
  # call the function that will print the collected errors
  if @options[:debug] and exceptions_list.count > 0
    apiCallPrintError(resource, action, params, step, exceptions_list)
  end
  # if the step used are greater then the maxstep
  if step >= @options[:maxstep] and exiting
    puts_standard "Exiting from program"
    exit 1
  end
  # return the results of the api call and the errors
  return results, api_error
end

# print the error of the API call if present
def apiCallPrintError(resource, action, params, step, exceptions_list)
  puts_error "###"
  puts_error "ERROR: API Call failed for #{step} time(s). See error log:"
  puts_error "API #{resource} / #{action} with this parameters"
  puts_error params
  exceptions_list.each do |single_exception|
    puts_error "---"
    puts_error "FAIL ##{single_exception["step"].to_i}: #{single_exception["time"]} - #{single_exception["message"]}"
    puts_error "#{single_exception["response"]}"
  end
  puts_error "###"
end


## MARK: Concurrency management functions

@subscription_queue = {}

# create subscriptions queue for concurrency
def create_subscription_queue ()
  puts_verbose "Start creating subscription queue for concurrency resource."
  @subscription_queue = {}
  # loop all the parsed subscriptions and create the resources to be consumed
  @yaml[:subs].each do |sub_entry|
    puts_verbose "Sub Entry: #{sub_entry['sub_parsed']}"
    # skip the subs entry if there isn't any sub parsed
    next if not sub_entry.has_key?('sub_parsed')
    sub_entry['sub_parsed'].each do |product, parsed_subscriptions|
      parsed_subscriptions.each do |sub|
        if @subscription_queue.has_key?(sub)
          next
        end
        # if the resource for the sub isn't yet created allocated it
        # the lock systems follow the rule of producer & consumer semaphore that is implemented in the Queue object of Ruby
        @subscription_queue[sub] = Queue.new
        @subscription_queue[sub] << sub
      end
    end
  end
  puts_verbose "Queue fetching completed."
  puts_verbose "#{@subscription_queue.class}"
  @subscription_queue.each do |key, value|
    puts_verbose "SUB QUEUE: #{key} - #{value}"
  end
end

# function that lock a subscriptions to be used
def lock_subscription (sub)
  # lock is required only for "NORMAL" subscription as the derivated are "unlimited"
  if sub['type'] != "NORMAL"
    puts_verbose "No lock required as subscription #{sub['cp_id']} type is #{sub['type']}"
    return
  end
  # exit if the subscription reousrces isn't allocated
  if not @subscription_queue.has_key?(sub['cp_id'])
    puts_standard "LOCK FATAL ERROR: Queue #{sub} not found in queue resource."
    exit 5
  end
  # try to consume one instance of the subscriptions
  # if the resources is already consumed by another Thread the current one will wait the push of the reousrce
  @subscription_queue[sub['cp_id']].pop
  # consuming the instance of the subscription
  puts_verbose "Locking instance of subscription #{sub['cp_id']}"
end

# function that unlock a subscription that is used
def unlock_subscription (sub)
  # lock is required only for "NORMAL" subscription as the derivated are "unlimited"
  if sub['type'] != "NORMAL"
    puts_verbose "No lock on subscription #{sub['cp_id']} as type is #{sub['type']}"
    return
  end
  # exit if the subscription resources isn't allocated
  if not @subscription_queue.has_key?(sub['cp_id'])
    puts_standard "UNLOCK FATAL ERROR: Queue #{sub['cp_id']} not found in queue resource."
    exit 5
  end
  # return the resource by pushing resources in the Queue
  if @subscription_queue[sub['cp_id']].size == 0
    puts_verbose "Unlocking instance of subscription #{sub['cp_id']}"
    @subscription_queue[sub['cp_id']] << sub
  end
end


## MARK: Cache Reader Functions

# read the cache searching for key in file, if cachekey isn't setted read as json cachefile
def readfromcache(cachefile, cachekey)
  result = nil
  if not File.file?(cachefile)
    puts_standard "FATAL ERROR: --read-from-cache option requested, but the cache file is not currently present."
    exit 5
  end
  if not cachekey.empty?
    result = []
    result = readfromYAMLcache(cachefile, cachekey)
  else
    result = {}
    result = readfromJSONcache(cachefile)
  end
  puts_debug "", result
  return result
end

# read the array of object saved in 'yamlkey' for a yaml cachefile
def readfromYAMLcache(yamlcachefile, yamlkey)
  cache_result = []
  begin
    cacheyaml = YAML.load_file(yamlcachefile)
    cache_result = cacheyaml[yamlkey]
  rescue Exception
    abort "FATAL ERROR: Failed to read #{yamlkey} from #{yamlcachefile} cache file. re-run without --read-from-cache."
  end
  return cache_result
end

# read the json content from the cache file passed in cache_file
def readfromJSONcache(jsoncachefile)
  cache_result = {}
  begin
    raw_json = File.read(jsoncachefile)
    cache_result = JSON.parse(raw_json)
  rescue Exception
    abort "FATAL ERROR: Failed to read json #{jsoncachefile} cache file. re-run without --read-from-cache."
  end
  return cache_result
end


## MARK: Improved output functions

# print output by adding the thread number
def puts_thread(put_string, std_error = nil)
  # check if the puts_thread function was called by the main thread
  if not Thread.main.object_id == Thread.current.object_id
    thread_id = "[#{Thread.current.object_id}] - "
  end
  # wrote the output in stderror or stdoutput
  if not std_error == "error"
    puts "#{thread_id}#{put_string}"
  else
    STDERR.puts "#{thread_id}#{put_string}"
  end
end

# print in verbose way the output, wrapper of puts_thread
def puts_verbose(output_string)
  if @options[:verbose] && output_string.length > 0
    puts_thread("VERBOSE: #{output_string}")
  end
end

# print in debug way the output, wrapper of puts_thread
def puts_debug(output_string, dump_object = nil)
  if @options[:debug] && output_string.length > 0
    puts_thread("DEBUG: #{output_string}")
    if dump_object
      puts_thread(dump_object)
    end
  end
end

# print normally the string in standard output, wrapper of puts_thread
def puts_standard(output_string)
  if output_string.length > 0
    puts_thread(output_string)
  end
end

# print normally the string in standard error, wrapper of puts_thread
def puts_error(output_string)
  if output_string.length > 0
    puts_thread(output_string, "error")
  end
end

# main function to be called
checksubs
subsupdate
